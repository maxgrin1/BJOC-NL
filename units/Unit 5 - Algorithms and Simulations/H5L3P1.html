<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script type="text/javascript" src="/bjc-r/llab/loader.js"></script>
    <title>Hoofdstuk 5 Les 3: Timing Experimenten, pagina 1</title>
</head>


<body>
    <h2>Het vergelijken van algoritmen</h2>
    <div class="todo">
        <ul>
            <li><strong>EK 4.1.1H</strong> Different algorithms can be developed to solve the same problem.</li>
            <li><strong>EK 4.1.1I</strong> Developing a new algorithm to solve a problem can yield insight into the
                problem.</li>
            <li><strong>EK 4.2.4A</strong> Determining an algorithm's efficiency is done by reasoning formally or
                mathematically about the algorithm.</li>
            <li><strong>EK 4.2.4D</strong> Different correct algorithms for the same problem can have different
                efficiencies.</li>
            <li><strong>EK 5.5.1G</strong> Intuitive and formal reasoning about program components using Boolean
                concepts helps in developing correct programs.</li>
        </ul>
    </div>
    <div class="todo">
        <p>We should change the CSS so that sidenotes never extend behind the element they are about; add space to the
            element if necessary. For example, that "Read this out loud" box shouldn't overlap the orange. --MF,
            12/27/17</p>
        <p>Brian also wants to change the katex in 5 and make the narrower box light blue here. --MF, 12/27/17</p>
    </div>


    <!--<div class="sidenoteBig">This introductory box is a new design feature that the BJC development team is considering using throughout the student lab pages. Its goal is to help students anticipate what they will be working on.<br />Is it helpful to you? How could we make it better? Please use the blue feedback button at the bottom to support BJC with your ideas!</div>-->
    <div class="learn">
        <p><strong>In deze les</strong> leer je dat sommige manieren om problemen op te lossen sneller zijn dan andere.<p>
            <strong>Op deze pagina,</strong> vergelijk je twee algortimen om het de nummers 1 tot en met een invoernummer bij elkaar op te tellen(zoals hieronder te zien is).<br />
            <img class="indent" src="/bjc-r/img/5-algorithms/sum-from-1-to-5-reporting.png"
                alt="sum from 1 to (5) reporting 15" title="sum from 1 to (5) reporting 15" />
        </p>
    </div>

    <div class="dialogue">
        <div class="stagedir">
            Alex en Robin maken een algoritme dat een integer als invoer neemt, om vervolgens de som van alle integers vanaf 1 tot het invoernummer terug te rapporteren. Zoals zo:<br />
            <img class="indent" src="/bjc-r/img/5-algorithms/sum-from-1-to-13-reporting.png"
                alt="sum from 1 to (13) reporting 91" title="sum from 1 to (13) reporting 91" /><br />
            Hun twee verschillende benaderingen geven altijd hetzelfde resultaat. Alex en Robin bespreken hun verschillende benaderingen.
        </div>
        <div><span>Alex: </span> Ik heb twee nieuwe blokken aangemaakt. Als eerste heb ik een resultaatblok aangemaakt dat alle integers ertussen vermeld. Daarna gebruikte ik
        <code>Combineren</code> om alles in de lijst op te tellen.</div>
        <div class="narrower">
            <div class="todo">Formatting needs clean-up, no? This is a little overwhelming... --MF, 7/3/18</div>

            <p>
                Het <img class="inline" src="/bjc-r/img/blocks/combine.png" alt="combine with() items of ()"
                    title="combine with() items of ()" /> blok neemt een operatie  (met <em>twee</em> blanco invoervelden)
                en een lijst als invoer, en rapporteert vervolgens een enkel resultaat (niet een lijst): de combinatie van de elementen in de lijst bij de gegeven operatie. Bijvoorbeeld:<br />
                <div class="sidenote">Wanneer je dit hardop uitspreekt zeg je het als "combineer de elementen van de lijst {5, 6, 2, 3} middels
                    additie."</div>
                <img class="indent" src="/bjc-r/img/3-lists/combine-example-1.png"
                    alt="combine with (()+()) items of (list {5,6,2,3}) reporting 16"
                    title="combine with (()+()) items of (list {5,6,2,3}) reporting 16" />
                <!--<img class="indent" src="/bjc-r/img/3-lists/combine-example-2.png" alt="combine with (join words () ()) items of (list {apples, bananas, oranges, grapes}) reporting 'apples bananas oranges grapes'" title="combine with (join words () ()) items of (list {apples, bananas, oranges, grapes}) reporting 'apples bananas oranges grapes'" />-->
            </p>
            <div class="takeNote">
                <div class="sidenoteBig"><code>Combineren</code> is een <em>hogere orde functie</em>. Dit betekend dat het een functie is dat een functie neemt als invoer.
                    Je hebt voorheen al diverse hogere orde functies gezien:
                    <code>For each</code> (in <a
                        href="/bjc-r/cur/programming/2-complexity/2-data-structures-art/1-the-for-each-block.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment"
                        title="Processing Each Item in a List">Hoofdstuk 2 Les 2</a>), <code>keep</code> (in <a
                        href="/bjc-r/cur/programming/2-complexity/3-predicates/2-keeping-list-items.html?topic=nyc_bjc%2F2-conditionals-abstraction.topic&course=bjc4nyc.html&novideo&noassignment"
                        title="Keeping Items from a List">Hoofdstuk 2 Les 3</a>), en <code>map</code> (in <a
                        href="/bjc-r/cur/programming/3-lists/1-introduction-to-lists/4-mapping-over-list.html?topic=nyc_bjc%2F3-lists.topic&course=bjc4nyc.html&novideo&noassignment"
                        title="Transforming Every List Item">Hoofdstuk 3 Les 1</a>).</div>
                <p>Jij kiest de operatie en <code>combineren</code> voert deze operatie uit door het <em>combineren</em> van
                    alle items in de invoerlijst en rapporteert het resultaat.</p>
                <p>Merk op dat de functie gebruikt om de lijst te <em>combineren</em> altijd twee blanco invoervelden heeft.
                    Zowel <code>map</code> als <code>keep</code> hebben slechts een invoerveld, maar met <code>combineren</code>, er twee vereist zijn.</p>
            </div>

            <div class="endnote">
                Anders dan <code>map</code> en <code>keep</code>, wordt <code>combineren</code> het meeste gebruikt met een van de volgende zes </em> functions:<br />
                <img class="indent" src="/bjc-r/img/3-lists/plus.png" alt="+" title="+" /> <img
                    src="/bjc-r/img/3-lists/times.png" alt="&times;" title="&times;" /><br />
                <img class="indent" src="/bjc-r/img/3-lists/and-block.png" alt="and" title="and" /> <img
                    src="/bjc-r/img/3-lists/or-block.png" alt="or" title="or" /><br />
                <img class="indent" src="/bjc-r/img/3-lists/join.png" alt="join" title="join" /> <img
                    src="/bjc-r/img/3-lists/join-words.png" alt="join words" title="join words" /><br />
                Voor blokken die je mogelijk zelf wilt maken zijn er eigenlijk maar twee kandidaten:<br />
                <img class="indent" src="/bjc-r/img/3-lists/max.png" alt="max" title="max" /> <img
                    src="/bjc-r/img/3-lists/min.png" alt="min" title="min" /><br />
                <a data-toggle="collapse" href="#hint-3">Waarom zo weinig?</a>
                <div id="hint-3" class="collapse">
                    De functie moet <em>associatief</em> zijn. Dit betekend dat het niet uitmaakt in welke volgorde je de items groupeert; (7&thinsp;+&thinsp;8)&thinsp;+&thinsp;1 is the same as
                    7&thinsp;+&thinsp;(8&thinsp;+&thinsp;1) (zoek het zelf uit), maar
                    (7&thinsp;−&thinsp;8)&thinsp;−&thinsp;1 is anders van 7&thinsp;−&thinsp;(8&thinsp;−&thinsp;1).
                    dus <img src="/bjc-r/img/3-lists/combine-minus.png" alt="combine with (-) items of (list 7 8 1)">
                    zou onzinnig zijn.
                </div>
            </div>
        </div>
        <div class="stagedir">
            Alex laat zijn werk zien:<br />
            <img src="/bjc-r/img/5-algorithms/list-from-1-to-7-reporting.png"
                alt="list from (1) to (7) reporting the list{1,2,3,4,5,6,7"
                title="list from (1) to (7) reporting the list{1,2,3,4,5,6,7}" /><br />
            <img class="" src="/bjc-r/img/5-algorithms/sum-of-definition.png"
                alt="sum of (inputList){report(combine with(()+()) items of (inputList))}"
                title="sum of (inputList){report(combine with(()+()) items of (inputList))}" />

        </div>
        <div><span>Bo: </span> Geweldig! Maar ik denk dat het ook anders kan.</div>
        <div><span>Alex: </span> Cool! Hoe?</div>
        <div><span>Bo: </span> Ik zelf dacht aan additie. Ook merkte ik op dat 1 + 13 = 14 en 2 + 12 = 14 em 3 + 11
            = 14...</div>
        <div><span>Alex: </span> Dus, je hebt de veertienen opgeteld? </div>
        <div><span>Bo: </span> Yeah. Ik heb de lijst van 1 tot 13 opgeschreven, daarna exact hetzelfde maar dan omgekeerd&mdash;rechtonder mijn eerste lijst:</div>
        <div class="stagedir">Bo schrijft op het bord:</div>
        <table class="additiontable center"
            summary="setup for 13 simultaneous additions: the numbers 1 through 13 added to the numbers 13 through 1"
            role="presentation">
            <tr>
                <td>1</td>
                <td>2</td>
                <td>3</td>
                <td>4</td>
                <td>5</td>
                <td>6</td>
                <td>7</td>
                <td>8</td>
                <td>9</td>
                <td>10</td>
                <td>11</td>
                <td>12</td>
                <td>13</td>
            </tr>
            <tr>
                <td>13</td>
                <td>12</td>
                <td>11</td>
                <td>10</td>
                <td>9</td>
                <td>8</td>
                <td>7</td>
                <td>6</td>
                <td>5</td>
                <td>4</td>
                <td>3</td>
                <td>2</td>
                <td>1</td>
            </tr>
        </table>
        <div><span>Betsy: </span> Daarna heb ik ze een voor een opgeteld en kreeg dertien keer een veertien:</div>
        <table class="additiontable center"
            summary="13 simultaneous additions each showing a total of 14: the numbers 1 through 13 added to the numbers 13 through 1"
            role="presentation">
            <tr>
                <td></td>
                <td>1</td>
                <td>2</td>
                <td>3</td>
                <td>4</td>
                <td>5</td>
                <td>6</td>
                <td>7</td>
                <td>8</td>
                <td>9</td>
                <td>10</td>
                <td>11</td>
                <td>12</td>
                <td>13</td>
            </tr>
            <tr>
                <td>+</td>
                <td>13</td>
                <td>12</td>
                <td>11</td>
                <td>10</td>
                <td>9</td>
                <td>8</td>
                <td>7</td>
                <td>6</td>
                <td>5</td>
                <td>4</td>
                <td>3</td>
                <td>2</td>
                <td>1</td>
            </tr>
            <tr class="last">
                <td></td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
                <td>14</td>
            </tr>
        </table>
        <div><span>Betsy: </span> en 13 keer 14 is 182...</div>
        <div><span>Alphie: </span> Maar het antwoord is</div>
        <div><span>Betsy: </span> Klopt. Ik heb elk nummer twee keer opgeteld, dus het antwoord is de helft van 182 wat 91 is.</div>
        <div class="stagedir"> Bo schrijft <span class="katex">\frac{13 \times 14}{2}</span><span class="katex"
                style="font-size: .9em;">=91</span>.</div>
        <div><span>Alex: </span> Oh, en als je de nummers 1 tot en met 50 op wilt tellen vermenigvuldig je 50 met 51 en deel je dat door twee <em>(Alex berekend)</em> 1275. </div>
        <div class="stagedir"> Alex schrijft <span class="katex">\frac{50 \times 51}{2}</span><span class="katex"
                style="font-size: .9em;">=1275</span>.</div>
        <div><span>Betsy:</span> <em>(smiling)</em> Dus in het algemeen, om de getallen 1 tot en met een nummer
            <em>n</em> bij elkaar op te tellen, vermenigvuldig je je invoergetal met een meer dan het invoergetal en deel je het resultaat door 2...</div>
        <div class="stagedir">
            Bo schrijft <span class="katex">\frac{n \times (n + 1)}{2}</span>.<br />
            vervolgens bouwt Bo het blok, Alex helpt met debuggen.
        </div>
    </div>

    <div class="forYouToDo" id="first">
        <ol>
            <li>Bespreek deze twee algoritmen en stel een hypothese op: welk algoritme denk jij dat het meest efficiënt is? En waarom?</li>
            <li>
                <div class="sidenoteBig">Voor de methode van Alex, gebruik het blok <code>numbers from () to ()</code> uit het variabelen pallet. Doe <img class="inline" src="/bjc-r/img/icons/import-tools.png"
                        alt="Import Tools" title="Import Tools" /> om het te zien.</div>
                Implementeer een <code>sum from 1 to</code> algoritme. Je kan gebruik maken van de manier van Alex(middels
                <code>Combineren</code> to code <code>sum</code>), of je gebruikt Bo´s formule, of je doet het op je eigen manier.<br />
                <div class="saveAs inline"><span class="text">"U5L3-ReporterTimer"</span><img
                        src="/bjc-r/img/icons/save-this-as.png" alt="Save your work as U5L3-ReporterTimer"
                        title="Save your work as U5L3-ReporterTimer" /></div>
            </li>
            <li>Werk samen met een ander team en vergelijk Alex's and Bo's algoritme met een variatie aan invoeren. Bepaal welk algoritme 
                het meest efficiënt is(dat is degene die het snelst gaat).</li>
            <li>
                In opdracht 3, heb je timing experimenten gebruikt om uit te vinden welk algoritme het snelste is. Je kan ook
                <em>formeel redeneren</em> gebruiken om te bewijzen dat het ene algoritme sneller is dan de ander:
                <ol>
                    <li>Wanneer je de nummers 1 t/m 100 optelt, hoeveel rekenkundige handelingen (+, &ndash;, &times;,
                        &divide;) heeft Bo´s algoritme nodig?</li>
                    <li>Hoeveel rekenkundige handelingen zal Alex´ methode gebruiken?</li>
                    <li>Wat als je de getallen 1 t/m 1000 optelt?</li>
                    <li>Is de som van alle rekenkundige handelingen logisch in vergelijking tot het experimentele resultaten in
                        opdracht 3?</li>
                </ol>
            </li>
        </ol>
    </div>

    <div class="ifTime">
        <ol start="5">
            <li>Als je een <a
                    href="/bjc-r/cur/programming/3-lists/4-graphing/2-building-a-grapher.html?topic=nyc_bjc%2F5-algorithms.topic&course=bjc4nyc.html&novideo&noassignment"
                    title="Building a Graphing App">teken app</a> gemaakt hebt, probeer de volgende functie te plotten: <span class="katex">y=</span>
                <code>sum from 1 to(</code> <span class="katex">x</span><code>)</code>.</li>
        </ol>
    </div>


</body>

</html>
